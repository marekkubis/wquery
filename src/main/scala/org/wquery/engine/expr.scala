package org.wquery.engine
import org.wquery.WQueryEvaluationException
import org.wquery.model.{WordNet, IntegerType, Relation, DataType, StringType, SenseType, Sense, BasicDataType, UnionType, ValueType, TupleType, AggregateFunction, ScalarFunction, FloatType, FunctionArgumentType}
import scala.collection.mutable.ListBuffer

sealed abstract class Expr

sealed abstract class EvaluableExpr extends Expr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context): DataSet
}

sealed abstract class ContextFreeExpr extends EvaluableExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings): DataSet

  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context): DataSet = evaluate(functions, wordNet, bindings)
}

sealed abstract class BindingsFreeExpr extends ContextFreeExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet): DataSet

  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings): DataSet = evaluate(functions, wordNet)
}

sealed abstract class FunctionsFreeExpr extends BindingsFreeExpr {
  def evaluate(wordNet: WordNet): DataSet

  def evaluate(functions: FunctionSet, wordNet: WordNet): DataSet = evaluate(wordNet)
}

sealed abstract class SelfEvaluableExpr extends FunctionsFreeExpr {
  def evaluate(): DataSet

  def evaluate(wordNet: WordNet): DataSet = evaluate
}

/*
 * Imperative expressions
 */

sealed abstract class ImperativeExpr extends EvaluableExpr

case class EmissionExpr(expr: EvaluableExpr) extends ImperativeExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = {
    expr.evaluate(functions, wordNet, bindings, context)
  }
}

case class IteratorExpr(vars: List[String], mexpr: EvaluableExpr, iexpr: ImperativeExpr) extends ImperativeExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = {
    val mresult = mexpr.evaluate(functions, wordNet, bindings, context)
    val tupleBindings = new Bindings(Some(bindings))
    val buffer = new DataSetBuffer

    for (tuple <- mresult.content) {
      if (tuple.size >= vars.size) {  
        for (i <- 0 until vars.size) {
          tupleBindings.bind(vars(i), tuple(i))
        }
    
        buffer.append(iexpr.evaluate(functions, wordNet, tupleBindings, context))
      } else {
        throw new WQueryEvaluationException("A tuple generated by a path expression in an iterator contains" +
          " an insufficient number of elements to bind all variables")      
      }
    }

    buffer.toDataSet
  }
}

case class IfElseExpr(cexpr: EvaluableExpr, iexpr: ImperativeExpr, eexpr: Option[ImperativeExpr]) extends ImperativeExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = {
    val cresult = cexpr.evaluate(functions, wordNet, bindings, context)

    if (cresult.isTrue) {
      iexpr.evaluate(functions, wordNet, bindings, context)
    } else {
      eexpr match {
        case Some(eexpr) =>
          eexpr.evaluate(functions, wordNet, bindings, context)
        case None =>
          DataSet.empty
      }
    }
  }
}

case class BlockExpr(exprs: List[ImperativeExpr]) extends ImperativeExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = {
    val blockBindings = new Bindings(Some(bindings))
    val buffer = new DataSetBuffer

    for (expr <- exprs) {
      buffer.append(expr.evaluate(functions, wordNet, blockBindings, context))
    }

    buffer.toDataSet
  }
}

case class EvaluableAssignmentExpr(vars: List[String], expr: EvaluableExpr) extends ImperativeExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = {
    val eresult = expr.evaluate(functions, wordNet, bindings, context)

    if (eresult.content.size == 1) {
      val tuple = eresult.content.head

      if (vars.size == tuple.size) {
        for (i <- 0 until vars.size) {
          bindings.bind(vars(i), tuple(i))
        }

        DataSet.empty
      } else {
        throw new WQueryEvaluationException("A tuple generated by a path expression in an assignment contains" +
          " an insufficient number of elements to bind all variables")
      }

      DataSet.empty
    } else {
      throw new WQueryEvaluationException("A multipath expression in an assignment should contain exactly one tuple")
    }
  }
}

case class RelationalAssignmentExpr(name: String, rexpr: RelationalExpr) extends ImperativeExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = {
    bindings.bind(name, rexpr)
    DataSet.empty
  }
}

/*
 * Multipath expressions
 */
case class BinaryPathExpr(op: String, left: EvaluableExpr, right: EvaluableExpr) extends EvaluableExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = {
    val leval = left.evaluate(functions, wordNet, bindings, context)
    val reval = right.evaluate(functions, wordNet, bindings, context)

    op match {
      case "," =>
        DataSet(join(leval.content, reval.content))
      case op =>
        DataSet(
          op match {
            case "union" =>
              leval.content union reval.content
            case "except" =>
              leval.content.filterNot(reval.content.contains)
            case "intersect" =>
              leval.content intersect reval.content
            case _ =>
              throw new IllegalArgumentException("Unknown binary path operator '" + op + "'")
          })
    }
  }

  def join(left: List[List[Any]], right: List[List[Any]]) = {
    val buffer = new ListBuffer[List[Any]]

    for (ltuple <- left) {
      for (rtuple <- right) {
        buffer append (ltuple ++ rtuple)
      }
    }

    buffer.toList
  }
}

/*
 * Arithmetic expressions
 */
case class BinaryArithmExpr(op: String, left: EvaluableExpr, right: EvaluableExpr) extends EvaluableExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = {
    val lresult = left.evaluate(functions, wordNet, bindings, context)
    val rresult = right.evaluate(functions, wordNet, bindings, context)

    if (lresult.minPathSize > 0 && rresult.minPathSize > 0 && lresult.isNumeric(0) && rresult.isNumeric(0)) {
      if (lresult.getType(0) == IntegerType && rresult.getType(0) == IntegerType) {
        combineUsingIntArithmOp(op, lresult.content.map( x => x.last.asInstanceOf[Int]), rresult.content.map( x => x.last.asInstanceOf[Int]))
      } else {
        combineUsingDoubleArithmOp(op, 
          lresult.content.map(x => x.last).map {
            case x: Double => x            
            case x: Int => x.doubleValue
          },
          rresult.content.map(x => x.last).map {
            case x: Double => x              
            case x: Int => x.doubleValue
          }
        )
      }
    } else {
      throw new WQueryEvaluationException("Operator '" + op + "' requires numeric type ended datapaths") 
    }
  }

  def combineUsingIntArithmOp(op: String, leval: List[Int], reval: List[Int]) = {
    val func: (Int, Int) => Int = op match {
      case "+" =>
        (x, y) => x + y
      case "-" =>
        (x, y) => x - y
      case "*" =>
        (x, y) => x * y
      case "/" =>
        (x, y) => x / y
      case "%" =>
        (x, y) => x % y
      case _ =>
        throw new IllegalArgumentException("Unknown binary arithmetic operator '" + op + "'")
    }
    
    combine[Int](func, leval, reval)
  }    
  
  def combineUsingDoubleArithmOp(op: String, leval: List[Double], reval: List[Double]) = {
    val func: (Double, Double) => Double = op match {
      case "+" =>
        (x, y) => x + y
      case "-" =>
        (x, y) => x - y
      case "*" =>
        (x, y) => x * y
      case "/" =>
        (x, y) => x / y
      case "%" =>
        (x, y) => x % y
      case _ =>
        throw new IllegalArgumentException("Unknown binary arithmetic operator '" + op + "'")
    }
    
    combine[Double](func, leval, reval)
  }  

  def combine[A](func: (A, A) => A, leval: List[A], reval: List[A]) = {
    val buffer = new ListBuffer[List[Any]]

    for (lval <- leval) {
      for (rval <- reval) {
        buffer append List(func(lval, rval))
      }
    }

    DataSet(buffer.toList)
  }

}

case class MinusExpr(expr: EvaluableExpr) extends EvaluableExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = {
    val eresult = expr.evaluate(functions, wordNet, bindings, context)

    if (eresult.isNumeric(0)) {
        DataSet(eresult.content.map(x => x.last).map {
            case x: Int => List(-x)
            case x: Double => List(-x)
        })
    } else {
      throw new WQueryEvaluationException("Unary '-' requires a context that consist of integer or float singletons")       
    }
  }
}

/* 
 * Function call expressions
 */
case class FunctionExpr(name: String, args: EvaluableExpr) extends EvaluableExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = {
    val aresult = args.evaluate(functions, wordNet, bindings, context)
    
    val atypes: List[FunctionArgumentType] = if (aresult.minPathSize  != aresult.maxPathSize ) {
      List(TupleType)
    } else {
      ((aresult.maxPathSize - 1) to 0 by -1).map(x => aresult.getType(x)).toList.map {
          case UnionType(utypes) =>
            if (utypes == Set(FloatType, IntegerType)) ValueType(FloatType) else TupleType
          case t: BasicDataType =>
            ValueType(t)
      }
    }

    val (func, method) = functions.getFunction(name, atypes) match {
      case Some(f) => f
      case None =>
        // promote arg types from integers to floats
        functions.getFunction(
          name,
          atypes.map {
            case ValueType(IntegerType) =>
              ValueType(FloatType)
            case t => t
          }) match {
          case Some(f) => f
          case None =>
            functions.demandFunction(name, List(TupleType))
        }
    }

    func match {
      case func: AggregateFunction =>
        method.invoke(WQueryFunctions, aresult).asInstanceOf[DataSet]
      case func: ScalarFunction =>
        val buffer = new ListBuffer[List[Any]]()
        val margs = new Array[AnyRef](atypes.size)
        var stop = false

        for (tuple <- aresult.content) {
          for (i <- 0 until margs.size)
            margs(i) = tuple(i).asInstanceOf[AnyRef]

          buffer.append(List(method.invoke(WQueryFunctions, margs: _*)))
        }

        func.result match {
          case ValueType(dtype) =>
            DataSet(buffer.toList)
          case TupleType =>
            throw new RuntimeException("ScalarFunction '" + func.name + "' returned TupleType")
        }
    }
  }
}

/*
 * Path related expressions
 */
case class StepExpr(lexpr: EvaluableExpr, rexpr: TransformationDesc) extends EvaluableExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = {
    rexpr match {
      case RelationTransformationDesc(pos, rexpr) =>
        val lresult = lexpr.evaluate(functions, wordNet, bindings, context)

        rexpr.transform(wordNet, bindings, context, lresult, pos, false, false)
      case FilterTransformationDesc(cond) =>
        val lresult = lexpr.evaluate(functions, wordNet, bindings, context)

        DataSet(lresult.content.filter { tuple => 
          cond.satisfied(functions, wordNet, bindings, Context(tuple))
        })
    }
  }

}

sealed abstract class TransformationDesc extends Expr

case class RelationTransformationDesc(pos: Int, expr: RelationalExpr) extends TransformationDesc
case class FilterTransformationDesc(expr: ConditionalExpr) extends TransformationDesc

case class PathExpr(expr: EvaluableExpr) extends EvaluableExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = { //TODO extend this method or remove this class
    expr.evaluate(functions, wordNet, bindings, context)
  }
}

/*
 * Relational Expressions
 */
sealed abstract class RelationalExpr extends Expr {
  def transform(wordNet: WordNet, bindings: Bindings, context: Context, data: DataSet, pos: Int, invert: Boolean, force: Boolean): DataSet
}

case class UnaryRelationalExpr(identifier: IdentifierLit) extends RelationalExpr {
  def transform(wordNet: WordNet, bindings: Bindings, context: Context, data: DataSet, pos: Int, invert: Boolean, force: Boolean) = {
    if (force) {
      useIdentifierAsTransformation(identifier.value, wordNet, data, pos, invert)
    } else {
      identifier match {
        case QuotedIdentifierLit(wordForm) =>
          if (pos == 0) {
            useIdentifierAsGenerator(wordForm, wordNet, context, invert)
          } else {
            throw new WQueryEvaluationException("Quoted identifier found after '.'")
          }
        case NotQuotedIdentifierLit(relname) =>
          if (pos == 0) { // we are in a generator 
            if (context.isEmpty) { // we are not in a filter      
              useIdentifierAsGenerator(relname, wordNet, context, invert)
            } else {
              useIdentifierAsVariable(relname, wordNet, bindings, context, data, pos, invert, force) match {
                case Some(result) =>
                  result
                case None =>
                  if (wordNet.containsRelation(relname, data.getType(0))) {
                    useIdentifierAsTransformation(relname, wordNet, data, 1, invert)
                  } else {
                    useIdentifierAsGenerator(relname, wordNet, context, invert)
                  }
              }
            }
          } else {
            useIdentifierAsVariable(relname, wordNet, bindings, context, data, pos, invert, force) match {
              case Some(result) =>
                result
              case None =>
                useIdentifierAsTransformation(relname, wordNet, data, pos, invert)
            }
          }
      }
    }
  }

  private def useIdentifierAsVariable(id: String, wordNet: WordNet, bindings: Bindings, context: Context,
    data: DataSet, pos: Int, invert: Boolean, force: Boolean) = {
    bindings.lookup(id) match {
      case Some(rexpr: RelationalExpr) =>
        Some(rexpr.transform(wordNet, bindings, context, data, pos, invert, force))
      case _ =>
        None
    }
  }

  private def useIdentifierAsGenerator(id: String, wordNet: WordNet, context: Context, invert: Boolean) = {
    id match {
      case "" =>
        DataSet.fromList(wordNet.words.toList)
      case "false" =>
        DataSet.fromValue(false)
      case "true" =>
        DataSet.fromValue(true)
      case _ =>
        if (!invert) {
          DataSet.fromOptionalValue(wordNet.getWordForm(id))
        } else {
          if (context.isEmpty)
            throw new WQueryEvaluationException("'^' applied to the path generator")
          else
            throw new WQueryEvaluationException("Relation '" + id + "' not found")
        }
    }
  }

  private def useIdentifierAsTransformation(id: String, wordNet: WordNet, data: DataSet, pos: Int, invert: Boolean) = {
    val succfunc = if (invert) wordNet.getPredecessors(_, _, _) else wordNet.getSuccessors(_, _, _)
    val relation = wordNet.demandRelation(id, data.getType(pos - 1))
    val buffer = new ListBuffer[List[Any]]

    for (tuple <- data.content) {
      for (succ <- succfunc(tuple(tuple.size - pos), relation, Relation.Destination)) {
        buffer.append(tuple ::: List(succ))
      }
    }

    DataSet(buffer.toList)
  }
}

case class QuantifiedRelationalExpr(expr: RelationalExpr, quantifier: QuantifierLit) extends RelationalExpr {
  def transform(wordNet: WordNet, bindings: Bindings, context: Context, data: DataSet, pos: Int, invert: Boolean, force: Boolean) = {
    quantifier match {
      case QuantifierLit(1, Some(1)) =>
        expr.transform(wordNet, bindings, context, data, pos, invert, force)
      case QuantifierLit(1, None) =>
        val head = expr.transform(wordNet, bindings, context, data, pos, invert, force)
        val content = new ListBuffer[List[Any]]

        for (tuple <- head.content) {
          content.append(tuple)
          val prefix = tuple.slice(0, tuple.size - 1) // remove prefix variable put tuple to outer closure

          for (cnode <- closure(wordNet, bindings, context, expr, false, List(tuple.last), Set(tuple.last))) {
            content.append(prefix ++ cnode)
          }
          
        }
        
        DataSet(content.toList)
      case _ =>
        throw new IllegalArgumentException("Unsupported quantifier value " + quantifier)
    }
  }
  
  private def closure(wordNet: WordNet, bindings: Bindings, context: Context, expr: RelationalExpr,
    inverted: Boolean, source: List[Any], forbidden: Set[Any]): List[List[Any]] = {
    val transformed = expr.transform(wordNet, bindings, context, DataSet.fromTuple(source), 1, inverted, true)
    val filtered = transformed.content.filter { x => !forbidden.contains(x.last) }

    if (filtered.isEmpty) {
      filtered
    } else {
      val result = new ListBuffer[List[Any]]
      val newForbidden: Set[Any] = forbidden.++[Any, Set[Any]](filtered.map { x => x.last }) // TODO ugly

      result.appendAll(filtered)

      filtered.foreach { x =>
        result.appendAll(closure(wordNet, bindings, context, expr, inverted, x, newForbidden))
      }

      result.toList
    }
  }  
}

case class InvertedRelationalExpr(expr: RelationalExpr) extends RelationalExpr {
  def transform(wordNet: WordNet, bindings: Bindings, context: Context, data: DataSet, pos: Int, invert: Boolean, force: Boolean) = {
    expr.transform(wordNet, bindings, context, data, pos, !invert, force)
  }
}

case class UnionRelationalExpr(lexpr: RelationalExpr, rexpr: RelationalExpr) extends RelationalExpr {
  def transform(wordNet: WordNet, bindings: Bindings, context: Context, data: DataSet, pos: Int, invert: Boolean, force: Boolean) = {
    val lresult = lexpr.transform(wordNet, bindings, context, data, pos, invert, force)
    val rresult = rexpr.transform(wordNet, bindings, context, data, pos, invert, force)

    DataSet(lresult.content union rresult.content)
  }
}

/*
 * Conditional Expressions
 */
sealed abstract class ConditionalExpr extends Expr {
  def satisfied(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context): Boolean
}

case class OrExpr(exprs: List[ConditionalExpr]) extends ConditionalExpr {
  def satisfied(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = exprs.exists { x => x.satisfied(functions, wordNet, bindings, context) }
}

case class AndExpr(exprs: List[ConditionalExpr]) extends ConditionalExpr {
  def satisfied(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = exprs.forall { x => x.satisfied(functions, wordNet, bindings, context) }
}

case class NotExpr(expr: ConditionalExpr) extends ConditionalExpr {
  def satisfied(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = !expr.satisfied(functions, wordNet, bindings, context)
}

case class ComparisonExpr(op: String, lexpr: EvaluableExpr, rexpr: EvaluableExpr) extends ConditionalExpr {
  def satisfied(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = {
    val lresult = lexpr.evaluate(functions, wordNet, bindings, context).content.map(x => x.last)
    val rresult = rexpr.evaluate(functions, wordNet, bindings, context).content.map(x => x.last)

    op match {
      case "=" =>
        lresult == rresult
      case "!=" =>
        lresult != rresult
      case "in" =>
        lresult.forall(rresult.contains)
      case "pin" =>
        lresult.forall(rresult.contains) && lresult.size < rresult.size
      case "=~" =>
        if (rresult.size == 1 ) {
          // element context
          if (DataType(rresult.head) == StringType) {
            val regex = rresult.head.asInstanceOf[String].r

            lresult.forall {
              case elem: String =>
                regex findFirstIn (elem) match {
                  case Some(_) =>
                    true
                  case None =>
                    false
                }
            }
          } else {
            throw new WQueryEvaluationException("The right side of '" + op +
              "' should return exactly one character string value")
          }
        } else if (rresult.isEmpty) {
          throw new WQueryEvaluationException("The right side of '" + op + "' returns no values")
        } else { // rresult.pathCount > 0
          throw new WQueryEvaluationException("The right side of '" + op + "' returns more than one values")
        }
      case _ =>
        if (lresult.size == 1 && rresult.size == 1) {
          // element context
          op match {
            case "<=" =>
              WQueryFunctions.compare(lresult, rresult) <= 0
            case "<" =>
              WQueryFunctions.compare(lresult, rresult) < 0
            case ">=" =>
              WQueryFunctions.compare(lresult, rresult) >= 0
            case ">" =>
              WQueryFunctions.compare(lresult, rresult) > 0
            case _ =>
              throw new IllegalArgumentException("Unknown comparison operator '" + op + "'")
          }
        } else {
          if (lresult.isEmpty)
            throw new WQueryEvaluationException("The left side of '" + op + "' returns no values")
          if (lresult.size > 1)
            throw new WQueryEvaluationException("The left side of '" + op + "' returns more than one value")
          if (rresult.isEmpty)
            throw new WQueryEvaluationException("The right side of '" + op + "' returns no values")
          if (rresult.size > 1)
            throw new WQueryEvaluationException("The right side of '" + op + "' returns more than one values")

          // the following shall not happen
          throw new WQueryEvaluationException("Both sides of '" + op + "' should return exactly one value")
        }
    }
  }
}

/*
 * Generators
 */
case class SynsetAllReq() extends FunctionsFreeExpr {
  def evaluate(wordNet: WordNet) = DataSet.fromList(wordNet.synsets.toList)
}

case class SynsetByExprReq(expr: EvaluableExpr) extends EvaluableExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = {
    val eresult = expr.evaluate(functions, wordNet, bindings, context)

    if (eresult.pathCount == 1 && eresult.minPathSize == 1 && eresult.maxPathSize == 1) {
      if (eresult.getType(0) == SenseType) {
        DataSet(eresult.content.map { case List(sense: Sense) => List(wordNet.getSynsetBySense(sense)) })
      } else if (eresult.getType(0) == StringType) {          
        DataSet(eresult.content.flatMap { case List(wordForm: String) => wordNet.getSynsetsByWordForm(wordForm) }.map(x => List(x)))  
      } else {
        throw new WQueryEvaluationException("{...} requires an expression that generates either senses or word forms")  
      }           
    } else if (eresult.pathCount == 0) {
        DataSet.empty
    } else {
      throw new WQueryEvaluationException("{...} requires an expression that generates single element paths")        
    }
  }
}

case class SenseAllReq() extends FunctionsFreeExpr {
  def evaluate(wordNet: WordNet) = DataSet.fromList(wordNet.senses.toList)
}

case class SenseByWordFormAndSenseNumberAndPosReq(word: String, num: Int, pos: String) extends FunctionsFreeExpr {
  def evaluate(wordNet: WordNet) = DataSet.fromOptionalValue(wordNet.getSenseByWordFormAndSenseNumberAndPos(word, num, pos))
}

case class SenseByWordFormAndSenseNumberReq(word: String, num: Int) extends FunctionsFreeExpr {
  def evaluate(wordNet: WordNet) = DataSet.fromList(wordNet.getSensesByWordFormAndSenseNumber(word, num))
}

case class ContextByRelationalExprReq(expr: RelationalExpr) extends EvaluableExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = {
    expr.transform(wordNet, bindings, context, DataSet(List(context.values)), 0, false, false)
  }
}

case class WordFormByRegexReq(v: String) extends FunctionsFreeExpr {
  def evaluate(wordNet: WordNet) = {
    val regex = v.r
    val result = wordNet.words.filter { x =>
      regex findFirstIn (x) match {
        case Some(s) =>
          true
        case None =>
          false
      }
    }

    DataSet.fromList(result.toList)
  }
}

case class ContextByReferenceReq(ref: Int) extends EvaluableExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings, context: Context) = {
    if (context.size - ref >= 0) {
      val value = context.values(context.size - ref)
      DataSet.fromValue(if (value.isInstanceOf[List[_]]) value.asInstanceOf[List[_]].last else value)
    } else {
      throw new WQueryEvaluationException("Backward reference '" + List.fill(ref)("#").mkString +
        "' too far, the longest possible backward reference in this context is '" +
        List.fill(context.size)("#").mkString + "'")
    }
  }
}

case class ContextByVariableReq(variable: String) extends ContextFreeExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings) = {
    bindings.lookup(variable) match {
      case Some(value) =>
        DataSet.fromValue(value)
      case None =>
        throw new WQueryEvaluationException("A reference to unknown variable $" + variable + " found")
    }
  }
}

case class BooleanByFilterReq(cond: ConditionalExpr) extends ContextFreeExpr {
  def evaluate(functions: FunctionSet, wordNet: WordNet, bindings: Bindings) = DataSet.fromValue(cond.satisfied(functions, wordNet, bindings, Context.empty))
}

/*
 * Literals
 */
case class DoubleQuotedLit(value: String) extends SelfEvaluableExpr {
  def evaluate = DataSet.fromValue(value)
}

case class StringLit(value: String) extends SelfEvaluableExpr {
  def evaluate = DataSet.fromValue(value)
}

case class IntegerLit(value: Int) extends SelfEvaluableExpr {
  def evaluate = DataSet.fromValue(value)
}

case class SequenceLit(left: Int, right: Int) extends SelfEvaluableExpr {
  def evaluate = DataSet.fromList((left to right).toList)
}

case class FloatLit(value: Double) extends SelfEvaluableExpr {
  def evaluate = DataSet.fromValue(value)
}

case class BooleanLit(value: Boolean) extends SelfEvaluableExpr {
  def evaluate = DataSet.fromValue(value)
}

case class QuantifierLit(left: Int, right: Option[Int]) extends Expr

sealed abstract class IdentifierLit(val value: String) extends SelfEvaluableExpr {
  def evaluate = DataSet.fromValue(value)
}

case class NotQuotedIdentifierLit(override val value: String) extends IdentifierLit(value)
case class QuotedIdentifierLit(override val value: String) extends IdentifierLit(value)